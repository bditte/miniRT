#include "miniRT.h"

t_vector	transparent(t_ray r, t_scene s, t_vector p, t_vector n, int nbRebonds)
{
	t_vector direction_refract;
	t_vector transparent_n = n;
	t_vector i_pixel;
	float n1 = 1;
	float n2 = 1.3;
	t_vector tangent;
	float radical;
	t_vector offset;

	printf("nbReonds : %d\n", nbRebonds);
	vec_display(r.dir);
	i_pixel = vec_init(0,0,0);
	if (dot(r.dir, n) > 0)
	{
		n1 = 1.3;
		n2 = 1;
		transparent_n = vec_multiply_t(-1.0, n);
	}
	radical = 1-sqr(n1/n2)*(1-sqr(dot(transparent_n, r.dir)));
	if (radical > 0)
	{
		tangent = vec_multiply_t((n1/n2), (vec_substract(r.dir,vec_multiply_t(dot(r.dir, transparent_n), transparent_n))));
		offset = vec_multiply_t(0.01, transparent_n);
		direction_refract = vec_substract(tangent, vec_multiply_t(sqrt(radical),transparent_n));
		r = ray_init(vec_addition(p, offset), direction_refract);
		i_pixel = get_color(r, s, nbRebonds - 1);
		
	}
	return (i_pixel);
}

t_vector	sphere_color(t_ray r, t_scene s, int nbRebonds, int *t)
{
	t_vector p;
        t_vector n;
        t_vector vec_l;
        t_vector i_pixel;
	int has_inter;
        float t_light;

        int i;
        t_vector offset;
        if (nbRebonds == 0)
                return (vec_init(0,0,0));
        has_inter = intersection(s, r, &p, &n, &i, t);
        i_pixel = vec_init(0,0,0);
        if (has_inter)
        {

                if (s.spheres[i].mirror == 1)
                {
                        t_vector direction_miroir;

                        offset = vec_multiply_t(0.01, n);
                        direction_miroir = vec_substract(r.dir, vec_multiply_t(2 *dot(n, r.dir), n));
                        r = ray_init(vec_addition(p, offset), direction_miroir);
                        i_pixel = get_color(r, s, nbRebonds - 1);
                }
                else if (s.spheres[i].transparent == 1)
                        i_pixel = transparent(r, s, p, n, nbRebonds);
		else {
                        t_vector light_p;
                        t_vector light_n;
                        t_ray ray_light;
                        int light_i;
                        vec_l = vec_substract(s.l_position, p);
                        offset = vec_multiply_t(0.01, n);
                        ray_light = ray_init(vec_addition(p, offset), vec_normalize(vec_l));       
                        has_inter = intersection(s, ray_light, &light_p, &light_n, &light_i, &t_light);
                        double d_light2 = getNorme2(vec_l);

                        if (has_inter && t_light * t_light < d_light2)
                                i_pixel = vec_init(0,0,0);
                        else
                                i_pixel = vec_multiply_t(s.l_int * ft_max(0, dot(vec_normalize(vec_l), n)) /d_light2, s.spheres[i].albedo);

                }
        }
	else
		*t = 0;
        return (i_pixel);

}

t_vector	get_color(t_ray r, t_scene s, int nbRebonds)
{
	int		t;
	int		last_t;
	t_vector	color;
	t_vector	res;
	
	if (s.nbSpheres > 0)
	{
	
		color = sphere_color(r, s, nbRebonds, &t);
		if (t < last_t)
		{
			last_t = t;
			res = color;
		}
	}
	if (s.nbPlanes > 0)
	{
		color = plane__color(r, s, nbRebonds, &t);
                if (t < last_t)
                {
                        last_t = t;
                        res = color;
                }
	}
}

